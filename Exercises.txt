Module 1. Intro.
    Examples:

    Exercise:
        1) about commands :load(:l), :reload(:r), :type (:t)
Module 2. Starting out.
    Examples:

    Exercise: 
        1) What stands for logical "and" statement?
        2) What stands for logical "or" statement?
        3) What stands for logical "not" statement?
        4) Try to guess result of the statement below. 25 == 2.5
        5) What is the correct if statement? -- ex. below
        6) Whe have an list of Integers xs = [5, 9 , 10, 27, 40]. Write a function that doubles all the elements in it. (Tip* you can use list comperhantion). [5, 9 , 10, 27, 40] -> [10, 18, 20, 54, 80];
        7) We have two lists: xs = [1, 2, 3, 4, 5], ys = [1, 2, 3, 4 ,5]. Write a function getCorrdinates:: [Int]->[Int]->[(Int, Int)] that return list of all possible coordinates(in tuples), which are fit in the square (0,0), (0,2), (2,2), (2,0). [Figure]
        [1,2] [1,2] -> [(1,1),(1,2),(2,1),(2,2)]

Module 3. Types and typeclasses
    Examples:
        -- 3.1
        -- :t for type check

        {-
            :t 1
            :t 1.2
            :t 'с'
            :t "gl&hf"
            -- also expressions
            :t True || False
            :t head "gl&hf"
        -}

        -- Functions also have types
        toUpper :: Char -> Char
        toUpper 'a' = 'A'
        toUpper 'b' = 'B'
        toUpper 'c' = 'C'
        toUpper 'd' = 'D'
        toUpper 'e' = 'E'
        toUpper 'f' = 'F'
        toUpper 'g' = 'G'
        toUpper 'h' = 'H'
        toUpper 'i' = 'I'
        toUpper 'j' = 'J'
        toUpper 'k' = 'K'
        toUpper 'l' = 'L'
        toUpper 'm' = 'M'
        toUpper 'n' = 'N'
        toUpper 'o' = 'O'
        toUpper 'p' = 'P'
        toUpper 'q' = 'Q'
        toUpper 'r' = 'R'
        toUpper 's' = 'S'
        toUpper 't' = 'T'
        toUpper 'u' = 'U'
        toUpper 'v' = 'V'
        toUpper 'w' = 'W'
        toUpper 'x' = 'X'
        toUpper 'y' = 'Y'
        toUpper 'z' = 'Z'
        toUpper a = a

        uppercase :: String -> String
        uppercase xs = [toUpper c | c <- xs]

        {-
            To see types after any expression
            :set +t
            :t uppercase
            :t not
            uppercase "wassUP"
            5 == 6
        -}


        -- 3.2
        {-
            :t head
            :t fst
        -}

        -- 3.3 Typeclasses
        {-
            Eq
                :t (==) or :t (!=) 
            Ord
                :t (>) or :t compare
            Show
                :t show
            Read
                :t read
            Enum
                :t [1..5]
                :t succ
            Bounded
                :t minBound or :t maxBound
            Num
                :t 20
                20 :: Int
                20 :: Integer
                20 :: Float
                20 :: Double
            Integral
                Int and Integer
            Floating
                Float and Double

    Exercies:
        1) What is the type of following expression? 
            1.1) ’h’:’e’:’l’:’l’:’o’:[]
            1.2) [5,’a’]
            1.3) (5,’a’)
            1.4) (5::Int) + 10
            1.5) (5::Int) + (10::Double)
        2) What is the type of following expression?
            2.1) snd
            2.2) head
            2.3) null
        3) Try to guees type of function below. 
            middle (_,a,_) = a
        4) Type class that support equality testing ? Eq
        5) Type class that support comparing ? Ord
        6) Type class that converts any type to string ? Show

Module 4. Functions
    Examples:

    Exercies:
        1) Choose all right function declarations.
            func :: True -> String
            func :: True -> "Succes"
            func :: Bool -> Int -> Bool
            func :: (Num a) => [a] -> a
        2) Choose all function declarations that are took two numbers and returns whole number.
            func :: Float -> Float -> Integer
            func :: Float -> Integer -> Int
            func :: Int -> Float

        3) Write a function that changes position of first and second element. [1, 2, 3, 4] -> [2, 1, 3, 4]
        4) Write a function that takes a number 1 to 12 and returns month name. Use case expressions. func 1 -> "January"
        5) Write a function that find roots of quadratic equation. To simplify problem return string in form "Root a is 1 and b is 0;
        for quadratic equation "a^2 - 3a + 2 = 0"
            roots 1 (-3) 2 -> (1,2);
        
Module 5. Recursion
    Examples:
        --Sum
        sum' :: [Integer] -> Integer
        sum' []     = 0
        sum' (x:xs) = x + sum' xs

        --Product
        product' :: [Integer] -> Integer
        product' [] = 1
        product' (x:xs) = x * product' xs

        --Length
        length' :: [a] -> Int
        length' []     = 0
        length' (_:xs) = 1 + length' xs
        
        -- Maximum
        maximum' :: Ord a => [a] -> a
        maximum' [] = error "maximum of empty list"
        maximum' [x] = x
        maximum' (x:xs)
                | x > maxTail = x
                | otherwise = maxTail
                where maxTail = maximum' xs

        -- LastElement
        lastElement :: Ord a => [a] -> a
        lastElement [] = error "last not exist"
        lastElement [x] = x
        lastElement (x:xs) = lastElement xs

        -- Palindrome
        isPalindrome :: Ord a => [a] -> Bool
        isPalindrome [] = error "Empty list"
        isPalindrome [x] = True
        isPalindrome xs = (head xs) == (last xs) && (isPalindrome (init (tail xs)))

        -- Replicate
        replicate' :: (Num i, Ord i) => i -> a -> [a]
        replicate' n x
            | n<=0 =[]
            | otherwise = x:replicate' (n-1) x

        quicksort :: (Ord a) => [a] -> [a]
        quicksort [] = []
        quicksort (x:xs) = smallerSorted ++ [x] ++ biggerSorted
            where smallerSorted = quicksort [a | a <- xs, a <= x]
                  biggerSorted = quicksort [a | a <- xs, a > x]

    Exercises:
        1) Write a function that reverses a list. [1,2,3] -> [3,2,1]
        2) Write a function that checks if the number is power of two. 1 -> True
        3) Write a function that takes list and number i and drops every ith element from list. [1,2,3,4] 2 -> [1,3]
        4) Given an encoded string, return its decoded string. 
        Input: s = "3[a]2[bc]"; Output: "aaabcbc";
        5) First Nth of the fibonacci sequence. 10 -> 0 1 1 2 3 5 8 13 21 34;

Module 6. Higher order functions.
    Examples:
        1) :t (+5)

        2)
            gt100 = (>100)
            gt100 4
            gt100 150
        3)
            mod2 = (`mod` 2)
            mod2' = (mod 2)
            -- Quick quiz: what is the difference?
            

    Exercises:
        1) 
            1.1) \x -> [x]
            1.2) \x y z -> (x,y:z:[]) 
            1.3) \x->x+5
            1.4) \x -> "hello, world" 
            1.5) \x->x ’a’
            1.6) \x->x x 
            1.7) \x->x+x
        
        2)  Rewrite functions below using higher order functions:
            fun1 :: [Integer] -> Integer fun1 [] = 1
            fun1 (x:xs) | even x    = (x - 2) * fun1 xs
                        | otherwise = fun1 xs
        
        3)  fun2 :: Integer -> Integer 
            fun2 1 = 0
            fun2 n | even n = n + fun2 (n ‘div‘ 2) 
                   | otherwise = fun2 (3 * n + 1)
        

Module 7. Modules
        Examples:
        1) -- Exporting modules 
        Suppose the module A exports x and y. Then this table shows what names are brought into scope by the specified import statement:

            import declaration              Names brought into scope
            import A                        x, y, A.x, A.y
            import A()                      (nothing)
            import A(x)                     x, A.x
            import qualified A              A.x, A.y
            import qualified A()            (nothing)
            import qualified A(x)           A.x
            import A hiding ()              x, y, A.x, A.y
            import A hiding (x)             y, A.y
            import qualified A hiding ()    A.x, A.y
            import qualified A hiding (x)   A.y
            import A as B                   x, y, B.x, B.y
            import A as B(x)                x, B.x
            import qualified A as B         B.x, B.y
        
        
        2)  -- Data.List
            2.1)
                intersperse SomeElem Array(1th, 2nd, 3rd .. n^th) note. type of SomeElem eq. Array elem type.
                result: (array[1], SomeElem, Array[2], SomeElem, Array[3] .. SomeElem, Array[n]) => a -> [a] -> [a]
                ex. intersperse '-' "AKASHI" -> "A-K-A-S-H-I".
            2.2)
                intercalate SomeArray Array-of-arrays => [a] -> [[a]] -> [a]
                intercalate "-ga-" ["Akame","Kill"]
                res. "Akame-ga-kill"
            2.3)
                transpose [[1,1,1], [2,2,2], [3,3,3]] -> [[1,2,3], [1,2,3], [1,2,3]]
                transpose ["aaa", "bbb", "ccc"] -> ["abc", "abc", "abc"] .
            2.4)
                concat ["do","re","mi"] -> "doremi"
            2.5)
                and $ map (=='.') "A.K.A_Zhuzi"
                False
                or $ map (=='.') "A.K.A_Zhuzi"
                False
            2.6)
                any (`elem` ['a'..'z']) "Hajime_No_Ippo"
                True
            2.7)
                take 5 $ iterate (*2) 1
                [1, 2, 4, 8, 16]
            2.8)
                splitAt 3 "Tibout Courtois" -> produces tuple of array divinding it at to, first elem size at most 3
                ("Tib","out Courtois")
            2.9)
                takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]
                [6,5,4]
                
                takeWhile (/=' ') "This is a sentence"
                "This"
            2.10)
                span
            2.11)
                break
            2.12)
                sort
            2.13)
                group
            2.14)
                inits
                tails
            2.15)
                isInfixOf
                isPrefixOf
                isSuffixOf
            2.16)
                partition
            2.17)
                find
            2.18)
                elemIndex
            2.19)
                findIndex
            2.20)
                zipWith3
            2.21)
                lines
                unlines
            2.22)
                nub
            2.23)
                insert
                delete
            2.24)
                intersect
                union
            2.25)
                nubBy, deleteBy, unionBy, intersectBy and groupBy.
        3) -- Data.Char

            3.1)
                isControl checks whether a character is a control character.
            3.2)
                isSpace checks whether a character is a white-space characters. That in- cludes spaces, tab characters, newlines, etc.
            3.3)
                isLower checks whether a character is lower-cased.
            3.4)
                isUpper checks whether a character is upper-cased.
            3.5)    
                isAlpha checks whether a character is a letter.
            3.6)
                isAlphaNum checks whether a character is a letter or a number.
            3.7)
                isPrint checks whether a character is printable. Control characters, for instance, are not printable. isDigit checks whether a character is a digit.
            3.8)
                isOctDigit checks whether a character is an octal digit.
            3.9)
                isHexDigit checks whether a character is a hex digit.
            3.10)
                isLetter checks whether a character is a letter.
            3.11)    
                isMark checks for Unicode mark characters. Those are characters that combine with preceding letters to form latters with accents. Use this if you are French.
            3.12)    
                isNumber checks whether a character is numeric.
            3.13)    
                isPunctuation checks whether a character is punctuation.
            3.14)    
                isSymbol checks whether a character is a fancy mathematical or currency symbol.
            3.15)    
                isSeparator checks for Unicode spaces and separators.
            3.16)    
                isAscii checks whether a character falls into the first 128 characters of the Unicode character set. isLatin1 checks whether a character falls into the first 256 characters of Unicode.
            3.17)    
                isAsciiUpper checks whether a character is ASCII and upper-case.
            3.18)    
                isAsciiLower checks whether a character is ASCII and lower-case.
        4) -- Data.Map
            4.1) Map.map
            4.2) Map.fromList
            4.3) Map.empty Map.null
            4.4) Map.insert
            4.5) Map.findKey
            4.7) Map.singleton
            4.8) Map.fromListWith 
        5) -- Data.Set
            5.1) Set.fromList
            5.2) Set.intersection
            5.3) Set.difference
            5.4) Set.union
            5.5) Set.null Set.empty
            5.6) Set.size
            5.7) Set.singleton
            5.8) Set.filter
        6) -- Own modules
            module Geometry
              ( sphereVolume
              , sphereArea
              , cubeVolume
              , cubeArea
              , cuboidArea
              , cuboidVolume
              ) where
              sphereVolume :: Float -> Float
              sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)
              sphereArea :: Float -> Float
              sphereArea radius = 4 * pi * (radius ^ 2)
              cubeVolume :: Float -> Float
              cubeVolume side = cuboidVolume side side side
              cubeArea :: Float -> Float
              cubeArea side = cuboidArea side side side
              cuboidVolume :: Float -> Float -> Float -> Float
              cuboidVolume a b c = rectangleArea a b * c
              cuboidArea :: Float -> Float -> Float -> Float
              cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 +
              rectangleArea c b * 2
              rectangleArea :: Float -> Float -> Float
              rectangleArea a b = a * b

        Exercises:
            1) Create Algebra module with following functions:
                - unnownKatinus:: Float -> Float -> Float
                - unnownKatinus katinus hypotenuse = ...
                
                - katinus1 :: Float -> Float -> Float
                - katinus1 hypotenus sinx  = ...
                
                - katinus2 :: Float -> Float -> Float
                - katinus2 hypotenus cosx  = ...
            

    Module 8. Making Our Own Types and Type - classes
        Examples:
            1) Algebraic data types intro

            data Shape = Circle Float Float Float | Rectangle Float Float Float Float

            surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)

        Exercises:
            1) binary tree, construct binary tree from array
                data Tree a = Leaf | Node Integer (Tree a) (Tree a)
                deriving (Show, Eq)
                foldTree :: [a] -> Tree a

    Module 9. 
        Examples:

        Exercises:
            1) IO 
            2) Files & streams
            3) Args
            4) Random
            5) Exceptions

    Module 10.
        Examples:
        Exercises:

    Module 11.
        Examples:
        Exercises: 
            "../C11.hs"
    Module 12.
        Examples:
        Exercises:
            "../C12.hs"

    Module 13.
        Examples:
        Exercises:
            


                  


