Module 1. Intro.
    Examples:

    Exercise:
        1) about commands :load(:l), :reload(:r), :type (:t)
Module 2. Starting out.
    Examples:

    Exercise: 
        1)  What stands for logical "and", "or", "not" statement?
        2)  Try to guess result of the statement below. 25 == 2.5
        3)  What is the correct if statement? -- ex. below
        4)  Find the element at index k in list l
            findK k l = undefined
        5)  Get coordinates from two lists xs, ys.
            coordinates xs ys = undefined

Module 3. Types and typeclasses
    Examples:
        -- 3.1
        -- :t for type check

        {-
            :t 1
            :t 1.2
            :t 'с'
            :t "gl&hf"
            -- also expressions
            :t True || False
            :t head "gl&hf"
        -}

        -- Functions also have types
        removeNonUppercase :: String -> String
        removeNonUppercase st = [c | c <- st, elem c ['A'..'Z']]

        {-
            To see types after any expression
            :set +t
            :t uppercase
            :t not
            uppercase "wassUP"
            5 == 6
        -}


        -- 3.2
        {-
            :t head
            :t fst
        -}

        -- 3.3 Typeclasses
        {-
            Eq
                :t (==) or :t (!=) 
            Ord
                :t (>) or :t compare
            Show
                :t show
            Read
                :t read
            Enum
                :t [1..5]
                :t succ
            Bounded
                :t minBound or :t maxBound
            Num
                :t 20
                20 :: Int
                20 :: Integer
                20 :: Float
                20 :: Double
            Integral
                Int and Integer
            Floating
                Float and Double

    Exercies:
        1) What is the type of following expression? 
            1.1) ’h’:’e’:’l’:’l’:’o’:[]
            1.2) [5,’a’]
            1.3) (5,’a’)
            1.4) (5::Int) + 10
            1.5) (5::Int) + (10::Double)
        2) What is the type of following expression?
            2.1) snd
            2.2) head
            2.3) null
        3) Try to guees type of function below. 
            middle (_,a,_) = a
        4) Type class that support equality testing ? Eq
        5) Type class that support comparing ? Ord
        6) Type class that converts any type to string ? Show

Module 4. Functions
    Examples:
        1)
            lucky :: (Integral a) => a -> String  
            lucky 7 = "LUCKY NUMBER SEVEN!"  
            lucky x = "Sorry, you're out of luck, pal!" 
        2)  
            sayMe :: (Integral a) => a -> String  
            sayMe 1 = "One!"  
            sayMe 2 = "Two!"  
            sayMe 3 = "Three!"  
            sayMe 4 = "Four!"  
            sayMe 5 = "Five!"  
            sayMe x = "Not between 1 and 5"  
        3) 
            factorial :: (Integral a) => a -> a  
            factorial 0 = 1  
            factorial n = n * factorial (n - 1)  
        4) 
            charName :: Char -> String  
            charName 'a' = "Asan"  
            charName 'b' = "Bolat"  
            charName 'u' = "Usen"
        5)   
            addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
            addVectors a b = (fst a + fst b, snd a + snd b)  
        
            addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
            addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) 
        6)
            first :: (a, b, c) -> a  
            first (x, _, _) = x  
              
            second :: (a, b, c) -> b  
            second (_, y, _) = y  
              
            third :: (a, b, c) -> c  
            third (_, _, z) = z  

        7)
            let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]  
            [a+b | (a,b) <- xs]
            [4,7,6,8,11,4]
        8) 
            head' :: [a] -> a  
            head' [] = error "Can't call head on an empty list, dummy!"  
            head' (x:_) = x  
        9)  
            tell :: (Show a) => [a] -> String  
            tell [] = "The list is empty"  
            tell (x:[]) = "The list has one element: " ++ show x  
            tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y  
            tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y
        10)
            length' :: (Num b) => [a] -> b  
            length' [] = 0  
            length' (_:xs) = 1 + length' xs 
        11) 
            ghci> capital "Marat"  
            "The first letter of Dracula is M" 
        12)
            bmiTell :: (RealFloat a) => a -> String  
            bmiTell bmi  
                | bmi <= 18.5 = "You're underweight!"  
                | bmi <= 25.0 = "You're supposedly normal."  
                | bmi <= 30.0 = "You're really heavy!"  
                | otherwise   = "You're a whale, congratulations!"
        13)
            max' :: (Ord a) => a -> a -> a  
            max' a b   
                | a > b     = a  
                | otherwise = b  

            max' :: (Ord a) => a -> a -> a  
            max' a b | a > b = a | otherwise = b  
        14)
            myCompare :: (Ord a) => a -> a -> Ordering  
            a `myCompare` b  
                | a > b     = GT  
                | a == b    = EQ  
                | otherwise = LT 
        15)     
    Exercies:
        1)  Choose all right function declarations.
            func :: True -> String
            func :: True -> "Success"
            func :: Bool -> Int -> Bool
            func :: (Num a) => [a] -> a
        2)  Choose all function declarations that are took two numbers and returns whole number.
            func :: Float -> Float -> Integer
            func :: Float -> Integer -> Int
            func :: Int -> Float

        3)  Write a function that changes position of i'th and j'th element.
            change xs i j = undefined
        4)  Write a function that takes a number 1 to 12 and returns month name. Use case expressions. func 1 -> "January"
        5)  Write a function that find roots of quadratic equation. Only one is enough.
            roots x y z = undefined
        
Module 5. Recursion
    Examples:
        --Sum
        sum' :: [Integer] -> Integer
        sum' []     = 0
        sum' (x:xs) = x + sum' xs

        --Product
        product' :: [Integer] -> Integer
        product' [] = 1
        product' (x:xs) = x * product' xs

        --Length
        length' :: [a] -> Int
        length' []     = 0
        length' (_:xs) = 1 + length' xs
        
        -- Maximum
        maximum' :: Ord a => [a] -> a
        maximum' [] = error "maximum of empty list"
        maximum' [x] = x
        maximum' (x:xs)
                | x > maxTail = x
                | otherwise = maxTail
                where maxTail = maximum' xs

        -- LastElement
        lastElement :: Ord a => [a] -> a
        lastElement [] = error "last not exist"
        lastElement [x] = x
        lastElement (x:xs) = lastElement xs

        -- Palindrome
        isPalindrome :: Ord a => [a] -> Bool
        isPalindrome [] = error "Empty list"
        isPalindrome [x] = True
        isPalindrome xs = (head xs) == (last xs) && (isPalindrome (init (tail xs)))

        -- Replicate
        replicate' :: (Num i, Ord i) => i -> a -> [a]
        replicate' n x
            | n<=0 =[]
            | otherwise = x:replicate' (n-1) x

        quicksort :: (Ord a) => [a] -> [a]
        quicksort [] = []
        quicksort (x:xs) = smallerSorted ++ [x] ++ biggerSorted
            where smallerSorted = quicksort [a | a <- xs, a <= x]
                  biggerSorted = quicksort [a | a <- xs, a > x]

    Exercises:
        1) Write a function that reverses a list. [1,2,3] -> [3,2,1]
        2) Write a function that checks if the number is power of k. 
            isPowerOf n k = undefined
        3) Write a function that takes list and number i and drops every ith element from list. [1,2,3,4] 2 -> [1,3]
        4) Implement binary powering: 
            binpow k x = undefined
        5) First Nth of the fibonacci sequence. 10 -> 0 1 1 2 3 5 8 13 21 34;

Module 6. Higher order functions.
    Examples:
        1) :t (+5)

        2)
            gt100 = (>100)
            gt100 4
            gt100 150
        3)
            mod2 = (`mod` 2)
            mod2' = (mod 2)
            -- Quick quiz: what is the difference?
            

    Exercises:
        1)  Implement sorting function of list of tuples
                mySort comparator list = undefined

        2)  Implement sum function:
            sum' :: (Num a) => [a] -> a
            sum' = foldl (+) 0
        
        3)  maximum' :: (Ord a) => [a] -> a
            maximum' = foldr1 (\x acc -> if x > acc then x else acc)
        

Module 7. Modules
        Examples:
            1) -- Exporting modules 
            Suppose the module A exports x and y. Then this table shows what names are brought into scope by the specified import statement:

                import declaration              Names brought into scope
                import A                        x, y, A.x, A.y
                import A()                      (nothing)
                import A(x)                     x, A.x
                import qualified A              A.x, A.y
                import qualified A()            (nothing)
                import qualified A(x)           A.x
                import A hiding ()              x, y, A.x, A.y
                import A hiding (x)             y, A.y
                import qualified A hiding ()    A.x, A.y
                import qualified A hiding (x)   A.y
                import A as B                   x, y, B.x, B.y
                import A as B(x)                x, B.x
                import qualified A as B         B.x, B.y
            
            
            2)  -- Data.List
                2.1)
                    intersperse SomeElem Array(1th, 2nd, 3rd .. n^th) note. type of SomeElem eq. Array elem type.
                    result: (array[1], SomeElem, Array[2], SomeElem, Array[3] .. SomeElem, Array[n]) => a -> [a] -> [a]
                    ex. intersperse '-' "AKASHI" -> "A-K-A-S-H-I".
                2.2)
                    intercalate SomeArray Array-of-arrays => [a] -> [[a]] -> [a]
                    intercalate "-ga-" ["Akame","Kill"]
                    res. "Akame-ga-kill"
                2.3)
                    transpose [[1,1,1], [2,2,2], [3,3,3]] -> [[1,2,3], [1,2,3], [1,2,3]]
                    transpose ["aaa", "bbb", "ccc"] -> ["abc", "abc", "abc"] .
                2.4)
                    concat ["do","re","mi"] -> "doremi"
                2.5)
                    and $ map (=='.') "A.K.A_Zhuzi"
                    False
                    or $ map (=='.') "A.K.A_Zhuzi"
                    False
                2.6)
                    any (`elem` ['a'..'z']) "Hajime_No_Ippo"
                    True
                2.7)
                    take 5 $ iterate (*2) 1
                    [1, 2, 4, 8, 16]
                2.8)
                    splitAt 3 "Tibout Courtois" -> produces tuple of array divinding it at to, first elem size at most 3
                    ("Tib","out Courtois")
                2.9)
                    takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]
                    [6,5,4]
                    
                    takeWhile (/=' ') "This is a sentence"
                    "This"
                2.10)
                    span
                2.11)
                    break
                2.12)
                    sort
                2.13)
                    group
                2.14)
                    inits
                    tails
                2.15)
                    isInfixOf
                    isPrefixOf
                    isSuffixOf
                2.16)
                    partition
                2.17)
                    find
                2.18)
                    elemIndex
                2.19)
                    findIndex
                2.20)
                    zipWith3
                2.21)
                    lines
                    unlines
                2.22)
                    nub
                2.23)
                    insert
                    delete
                2.24)
                    intersect
                    union
                2.25)
                    nubBy, deleteBy, unionBy, intersectBy and groupBy.
            3) -- Data.Char

                3.1)
                    isControl checks whether a character is a control character.
                3.2)
                    isSpace checks whether a character is a white-space characters. That in- cludes spaces, tab characters, newlines, etc.
                3.3)
                    isLower checks whether a character is lower-cased.
                3.4)
                    isUpper checks whether a character is upper-cased.
                3.5)    
                    isAlpha checks whether a character is a letter.
                3.6)
                    isAlphaNum checks whether a character is a letter or a number.
                3.7)
                    isPrint checks whether a character is printable. Control characters, for instance, are not printable. isDigit checks whether a character is a digit.
                3.8)
                    isOctDigit checks whether a character is an octal digit.
                3.9)
                    isHexDigit checks whether a character is a hex digit.
                3.10)
                    isLetter checks whether a character is a letter.
                3.11)    
                    isMark checks for Unicode mark characters. Those are characters that combine with preceding letters to form latters with accents. Use this if you are French.
                3.12)    
                    isNumber checks whether a character is numeric.
                3.13)    
                    isPunctuation checks whether a character is punctuation.
                3.14)    
                    isSymbol checks whether a character is a fancy mathematical or currency symbol.
                3.15)    
                    isSeparator checks for Unicode spaces and separators.
                3.16)    
                    isAscii checks whether a character falls into the first 128 characters of the Unicode character set. isLatin1 checks whether a character falls into the first 256 characters of Unicode.
                3.17)    
                    isAsciiUpper checks whether a character is ASCII and upper-case.
                3.18)    
                    isAsciiLower checks whether a character is ASCII and lower-case.
            4) -- Data.Map
                4.1) Map.map
                4.2) Map.fromList
                4.3) Map.empty Map.null
                4.4) Map.insert
                4.5) Map.findKey
                4.7) Map.singleton
                4.8) Map.fromListWith 
            5) -- Data.Set
                5.1) Set.fromList
                5.2) Set.intersection
                5.3) Set.difference
                5.4) Set.union
                5.5) Set.null Set.empty
                5.6) Set.size
                5.7) Set.singleton
                5.8) Set.filter
            6) -- Own modules
                module Geometry
                  ( sphereVolume
                  , sphereArea
                  , cubeVolume
                  , cubeArea
                  , cuboidArea
                  , cuboidVolume
                  ) where
                  sphereVolume :: Float -> Float
                  sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)
                  sphereArea :: Float -> Float
                  sphereArea radius = 4 * pi * (radius ^ 2)
                  cubeVolume :: Float -> Float
                  cubeVolume side = cuboidVolume side side side
                  cubeArea :: Float -> Float
                  cubeArea side = cuboidArea side side side
                  cuboidVolume :: Float -> Float -> Float -> Float
                  cuboidVolume a b c = rectangleArea a b * c
                  cuboidArea :: Float -> Float -> Float -> Float
                  cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 +
                  rectangleArea c b * 2
                  rectangleArea :: Float -> Float -> Float
                  rectangleArea a b = a * b

        Exercises:
            1) Create module "Pifagor" with following:

                - thirdSide :: Float -> Float -> Float -> Float
                - thirdSide side1 side2 angle = 

                - area :: Float -> Float -> Float -> Float
                - area side1 side2 angle = 
                
            -- import Pifagor


    Module 8. Making Our Own Types and Type - classes
        Examples:
            1) Algebraic data types intro

            data Shape = Circle Float Float Float | Rectangle Float Float Float Float

            surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)
            2) 
                data Person = Person { firstName :: String  
                     , lastName :: String  
                     , age :: Int  
                     , height :: Float  
                     , phoneNumber :: String  
                     , flavor :: String  
                     } deriving (Show)  
            3) 
                data Car a b c = Car { company :: a  
                     , model :: b  
                     , year :: c   
                     } deriving (Show) 
            4) 
                tellCar :: Car -> String  
                tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y  

                ghci> let stang = Car {company="Ford", model="Mustang", year=1967}  
                ghci> tellCar stang  
                "This Ford Mustang was made in 1967" 
            5) 
                Type synonyms

                type String = [Char]  


                phoneBook :: [(String,String)]  
                phoneBook =      
                    [("betty","555-2938")     
                    ,("bonnie","452-2928")     
                    ,("patsy","493-2928")     
                    ,("lucille","205-2928")     
                    ,("wendy","939-8282")     
                    ,("penny","853-2492")     
                    ] 

            6) data List a = Empty | Value a (List a) deriving (Show, Read, Eq, Ord) 



        Exercises:
            1) binary tree, construct binary tree from array
                data Tree a = Leaf | Node Integer (Tree a) (Tree a)
                deriving (Show, Eq)
                foldTree :: [a] -> Tree a

            2) 

    Module 9. 
        Examples:
            1)
                main = putStrLn "hello, world"  
                ghc --make helloworld  
            2) 
                getLine 
            3)

        Exercises:
            1) 
                - Lets implement the UNIX echo command
                - The program arguments are simply printed to the standard output.
                - If the first argument is -n, this argument is not printed, and no trailing newline is printed
                main = undefined
            2) 
                - Write a lottery number picker
                - This function should take a StdGen instance, and produce a list of six unique numbers between 1 and 49, in numerical order
                
                lottery :: StdGen -> [Int]
                lottery gen = undefined
    Module 10.

    Module 11.
        Examples:
        Exercises: 
            "../C11.hs"
    Module 12.
        Examples:
        Exercises:
            "../C12.hs"

    Module 13.
        Examples:
        Exercises: 
            "../C13.hs"

    Module 14.
        Examples:
        Exercises: 
            "../C14.hs"    
            


                